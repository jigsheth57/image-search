#!/bin/bash

# Configuration
MODEL="gemma3:12b-it-qat"
# Set the directory containing the JPEG images
# IMAGE_DIR="/Volumes/data-r/Family Medias/Photos-Library"
IMAGE_DIR="/Users/jsheth/Downloads/image-data"
PROMPT="What is in this image? Describe it in detail."

echo "Starting batch image processing with model: $MODEL in directory: $IMAGE_DIR"
echo "---"

# 1. Check if the directory exists
if [ ! -d "$IMAGE_DIR" ]; then
    echo "Error: Directory not found at $IMAGE_DIR"
    exit 1
fi

# 2. Iterate over all .jpeg files in the specified directory
# The -name "*.jpeg" ensures we only get files with that extension.
# The 'while read -r IMAGE_PATH' loop safely handles filenames with spaces.
find "$IMAGE_DIR" -maxdepth 2 -type f -iname "*.jpeg" | while read -r IMAGE_PATH
do
    # Get the base filename (e.g., DSC_4010) without the extension and directory
    FILENAME_BASE=$(basename "$IMAGE_PATH" .jpeg)

    IMAGE_BASE_DIR=$(dirname "$IMAGE_PATH")

    # Define the output file path in the same directory as the image
    OUTPUT_FILE="${IMAGE_BASE_DIR}/${FILENAME_BASE}.txt"

    echo "Processing image: $IMAGE_PATH"

    # Check if the output file already exists to avoid reprocessing (optional optimization)
    if [ -f "$OUTPUT_FILE" ]; then
        echo "  - Note: Output file $OUTPUT_FILE already exists. Skipping."
        echo "---"
        continue # Skip to the next file
    fi

    # 3. Base64 encode the image without wrapping lines
    echo "  - Encoding image to base64..."
    # Use -w 0 for Linux base64 or --wrap=0 for macOS/BSD base64. Using -w 0 for broader compatibility.
    ENCODED_IMAGE=$(base64 -w 0 -i "$IMAGE_PATH" 2>/dev/null)

    # Check if encoding was successful (e.g., file not empty/corrupt)
    if [ -z "$ENCODED_IMAGE" ]; then
        echo "  - Error: Failed to base64 encode $IMAGE_PATH. Skipping."
        echo "---"
        continue
    fi

    # 4. Construct the JSON payload and pipe it to curl
    echo "  - Sending request to Ollama API..."

    # The payload is generated by 'cat <<EOF ... EOF' and piped to 'curl' using |
    API_RESPONSE=$(cat <<EOF | curl -s http://localhost:11434/api/chat -H "Content-Type: application/json" --data-binary @-
{
  "model": "$MODEL",
  "messages": [
    {
      "role": "user",
      "content": "$PROMPT",
      "images": ["$ENCODED_IMAGE"]
    }
  ],
  "stream": false
}
EOF
)

    # 5. Extract the actual text content using 'jq' (recommended) or save the raw JSON
    if command -v jq &> /dev/null
    then
        # Extract the content and save it to the new text file
        RESPONSE_TEXT=$(echo "$API_RESPONSE" | jq -r '.message.content')
        echo "$RESPONSE_TEXT" > "$OUTPUT_FILE"
        EXIF_TEXT=$(exiftool -CreateDate -GPSPosition "$IMAGE_PATH")
        echo "$EXIF_TEXT" >> "$OUTPUT_FILE"
        echo "  - Response stored in $OUTPUT_FILE"
    else
        # jq not found, save the full JSON response
        echo "  - Warning: jq not found. Saving full JSON response to $OUTPUT_FILE."
        echo "$API_RESPONSE" > "$OUTPUT_FILE"
    fi

    echo "---"

done

echo "Batch processing complete."
